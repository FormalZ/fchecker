module Verifier where

import Language.Java.Syntax
import Language.Java.Pretty
import Z3.Monad
import System.IO.Unsafe

import Folds


-- | Checks wether the negation unsatisfiable
isTrue :: Exp -> Z3 Bool
isTrue e = 
    do
        ast <- foldExp expAssertAlgebra (PreNot e)
        assert ast
        result <- check
        case result of
            Unsat -> return True
            _     -> return False
        
-- | Unsafe version of isTrue
unsafeIsTrue :: Exp -> Bool
unsafeIsTrue = unsafePerformIO . evalZ3 . isTrue

-- | Defines the convertion from an expression to AST so that Z3 can assert satisfiability
--   This is used to fold expressions generated by the WLP transformer, so not all valid Java expressions need to be handled
expAssertAlgebra :: ExpAlgebra (Z3 AST)
expAssertAlgebra = (fLit, fClassLit, fThis, fThisClass, fInstanceCreation, fQualInstanceCreation, fArrayCreate, fArrayCreateInit, fFieldAccess, fMethodInv, fArrayAccess, fExpName, fPostIncrement, fPostDecrement, fPreIncrement, fPreDecrement, fPrePlus, fPreMinus, fPreBitCompl, fPreNot, fCast, fBinOp, fInstanceOf, fCond, fAssign, fLambda, fMethodRef) where
    fLit lit       = case lit of
                        Int n -> mkInteger n
                        Word n -> error "word"
                        Float d -> mkRealNum d
                        Double d -> mkRealNum d
                        Boolean b -> mkBool b
                        Char c -> do sort <- mkIntSort
                                     mkInt (fromEnum c) sort
                        String s -> error "string"
                        Null -> do sort <- mkIntSort
                                   mkInt 0 sort
    fClassLit = undefined
    fThis = undefined
    fThisClass = undefined
    fInstanceCreation = undefined
    fQualInstanceCreation = undefined
    fArrayCreate = undefined
    fArrayCreateInit = undefined
    fFieldAccess = undefined
    fMethodInv = undefined
    fArrayAccess = undefined
    fExpName name = mkStringSymbol (prettyPrint name) >>= mkIntVar
    fPostIncrement = undefined
    fPostDecrement = undefined
    fPreIncrement = undefined
    fPreDecrement = undefined
    fPrePlus e = e
    fPreMinus e = do
                    ast <- e
                    zero <- mkInteger 0
                    mkSub [zero, ast]
    fPreBitCompl = undefined
    fPreNot e = e >>= mkNot
    fCast = undefined
    fBinOp e1 op e2    = case op of
                            Mult -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkMul [ast1, ast2]
                            Div -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkDiv ast1 ast2
                            Rem -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkRem ast1 ast2
                            Add -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkAdd [ast1, ast2]
                            Sub -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkSub [ast1, ast2]
                            LShift -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkBvshl ast1 ast2
                            RShift -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkBvashr ast1 ast2
                            RRShift -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkBvlshr ast1 ast2
                            LThan -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkLt ast1 ast2
                            GThan -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkGt ast1 ast2
                            LThanE -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkLe ast1 ast2
                            GThanE -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkGe ast1 ast2
                            Equal -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkEq ast1 ast2
                            NotEq -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      eq <- mkEq ast1 ast2
                                      mkNot eq
                            And-> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkAnd [ast1, ast2]
                            Or -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkOr [ast1, ast2]
                            Xor -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkXor ast1 ast2
                            CAnd -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkAnd [ast1, ast2]
                            COr -> do
                                      ast1 <- e1
                                      ast2 <- e2
                                      mkOr [ast1, ast2]
    fInstanceOf = undefined
    fCond = undefined
    fAssign = undefined
    fLambda = undefined
    fMethodRef = undefined